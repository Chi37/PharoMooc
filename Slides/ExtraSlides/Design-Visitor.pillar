{
    "title":"Visitor",
    "slidesid":"From the Design Corner"
}


${slide:title=Outline}$

- Visitor
- Visitor discussions
- Visitor variations


${slide:title=Visitor intent}$

Represent an operation to be performed on the elements of an object structure in a class separate from the elements themselves. 

Visitor lets you define a new operation without changing the classes of the elements on which it operates.


${slide:title=Visitor Design}$

+.>file://figures/Visitor-Design.png|width=50+

${slide:title=Little arithmetic expressions}$

- Supports one kind of number, and has +, *, (, )
- We want to evaluate expressions, and print them

Evaluating
[[[
1 + (3 * 2)
gives 7
]]]

Printing
[[[
+1*32
]]]

${slide:title=Expression hierarchy}$

+.>file://figures/Visitor-SimpleExpressionHierarchy.png|width=50+

${slide:title=Some expressions}$

1
[[[
ENumber value: 1
]]]

(3 \* 2)
[[[
Times left: (ENumber value: 3) right: (ENumber value: 2)
]]]

1 \+ (3 \* 2)
[[[
Plus
	left: (ENumber value: 1)
	right: (Times left: (ENumber value: 3) right: (ENumber value: 2))
]]]

Of course in Pharo we can just extend Number so no need of ENumber value: but this is a detail

${slide:title=Operation implementation}$

Two solutions:
- add methods for evaluating, printing, ... on Expression and its subclasses
- create a Visitor, add the visit methods on Expression and its subclasses, and implement visitors for evaluation, printing, ...

${slide:title=Expression first design}$

+.>file://figures/Visitor-ExpressionTree.png|width=50+


${slide:title=First design analysis}$

- What if we need a stack to print well the expressions?
-- Should we put it in the expressions even if this is related only to print?

- What if we need a table for mathematical expression only for the LaTeX exporter?
Why should we mix the information about the treatment of items and items themselves?

${slide:title=Expression Visitor}$

+.>file://figures/Visitor-ExpressionsVisitor.png|width=90+

${slide:title=Expression Visitor analysis}$

Each visitor knows what to do for a number, a plus and times operation

${slide:title=Evaluator Visitor}$

[[[
Evaluator >> visitNumber: aNumber
     ^ aNumber value
]]]

[[[
Evaluator >> visitPlus: anExpression
     |l r|
     l := anExpression left acceptVisitor: self.
     r := anExpression right acceptVisitor: self.
     ^ l + r
]]]

[[[
Evaluator >> visitTimes: anExpression
     |l r|
     l := anExpression left acceptVisitor: self.
     r := anExpression right acceptVisitor: self.
     ^ l * r 
]]]

${slide:title=Invoking the Visitor}$

[[[
Evaluator new evaluate: 
	(Plus 
		left: (ENumber value: 1) 
		right: (Times left: (ENumber value: 3) right: (ENumber value: 2)))
> 7 
]]]

[[[
Evaluator >> evaluate: anExpression
   ^ anExpression acceptVisitor: self
]]]	

${slide:title=Printer}$

[[[
Visitor subclass: #Printer
   iv: 'stream level'
]]]
[[[
Printer >> visitNumber: aNumber
     stream nextPutAll: aNumber value asString
]]]

[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '+'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]
[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '*'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]


${slide:title=Visitor study}$

Check the double dispatch
- The Visitor knows the elementary operation. 
- The items declare how they want to be visited. 

+.>file://figures/Visitor-ExpressionsVisitor.png|width=60+

${slide:title=Controlling the traversal}$

Somewhere in the visitor, items are traversed.
Different places where the traversal can be implemented:
in the visitor
on the items hierarchy

${slide:title=Visitor Controlling}$

+.>file://figures/Visitor-ItemControl.png|width=90+

${slide:title=Visitor Example}$

+.>file://figures/colorizer.pdf|width=90+



${slide:title=Misopportunities}$

+.>file://figures/Visitor-donodeStupid.png|width=90+

${slide:title=Using messages as cases (again) }$

+.>file://figures/Visitor-DonodeClever.png|width=90+





${slide:title=Visitor Reflective}$

+.>file://figures/VisitorReflectiveImplementation.png|width=90+






${slide:title=When to use a Visitor}$

- Whenever you have a number of items on which you have to perform a number of actions
- When you ‘decouple’ the actions from the items.

Examples:
- Parse tree (ProgramNode) uses a visitor for the compilation (emitting code on CodeStream)
- Rendering documents (Document) in different formats


${slide:title=Some concerns}$
So all our problems are solved, no?
- how to define it
- when to use a visitor
- control over item traversal
- choosing the granularity of visitor methods
- implementation tricks








${slide:title=Visitor is not OOP controversy}$

Yes operations applied on objects are defined outside the objects.
But
- May be the operations require a complex state that has nothing to do with the structure (RTF/PDF stack)
- Each Visitor encapsulates a complex operation

${slide:title=Class extension}$

Even if a language supports class extension (defining methods on a class from another package than the class package), using a visitor is better because
- Each Visitor encapsulates a complex operation
- Each Visitor has its own state

${slide:title=Conclusion}$

- Having only one instance at a time
- Avoid Singleton as a global 


