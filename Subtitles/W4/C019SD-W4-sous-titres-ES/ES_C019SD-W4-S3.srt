1
00:00:00,520 --> 00:00:04,240
Buenos dias a todos. En esta
tercera secuencia, despues de 

2
00:00:04,440 --> 00:00:08,830
interesarnos por la herencia,
self y el lookup, vamos a 

3
00:00:09,030 --> 00:00:09,790
interesarnos por super.

4
00:00:11,130 --> 00:00:12,690
En esta secuencia,
vamos a interesarnos

5
00:00:12,890 --> 00:00:17,690
particularmente por el envio de mensajes
cuando super es el receptor.

6
00:00:18,380 --> 00:00:19,460
Entonces que és super?

7
00:00:20,090 --> 00:00:23,000
Tomaros algunos minutos para
platearos la pregunta y

8
00:00:23,200 --> 00:00:24,860
en todo caso responder a estas 2 preguntas.

9
00:00:26,120 --> 00:00:28,330
Que representa super?

10
00:00:30,480 --> 00:00:35,310
Como funciona el envio de mensajes
cuando super es el receptor?

11
00:00:35,510 --> 00:00:39,000
Lo que os voy a decir aqui,
és igual tanto en Pharo como en Java.


12
00:00:39,820 --> 00:00:44,680
En este ejemplo, que se 
parece a los ejemplos vistos

13
00:00:44,880 --> 00:00:48,840
en la secuencia anterior, utilizamos
super en uno de los metodos.

14
00:00:52,640 --> 00:00:55,470
Intentaremos pensar un poco 
en que es lo que ocurre.

15
00:00:56,670 --> 00:01:01,370
Para A new bar,
ninguna dificultad, como

16
00:01:01,570 --> 00:01:02,530
en el ejemplo anterior.

17
00:01:03,830 --> 00:01:08,090
Este metodo bar es ejecutado
y Foo devuelve 10.

18
00:01:10,380 --> 00:01:12,710
En el caso de B new bar,
lo haremos etapa por 

19
00:01:15,630 --> 00:01:19,600
etapa. Enviamos el mensaje bar
al objeto B new.

20
00:01:19,800 --> 00:01:24,250
El algoritmo de lookup 
busca un metodo

21
00:01:24,450 --> 00:01:26,940
bar a partir de la 
classe de este objeto.

22
00:01:27,440 --> 00:01:31,880
Ha encontrado el metodo bar,
que se  ejecuta

23
00:01:32,210 --> 00:01:36,660
en el receptor. Asi es
este metodo bar, aqui, el que

24
00:01:36,860 --> 00:01:38,350
se ejecutara en el receptor.

25
00:01:40,420 --> 00:01:44,910
Ahora  és neceesario que calcule
super bar, self foo y

26
00:01:45,110 --> 00:01:46,010
que haga la suma de los dos.

27
00:01:47,140 --> 00:01:48,110
Podemos hacer self foo.

28
00:01:48,310 --> 00:01:52,780
Self foo envia el mensaje
foo al objeto self.

29
00:01:53,000 --> 00:01:55,580
Self, és mi B new.

30
00:01:56,020 --> 00:02:00,190
Solo hay un foo posible, és
aquel que se encuentra en la classe A.

31
00:02:01,320 --> 00:02:02,080
Self foo devuelve 10.

32
00:02:04,870 --> 00:02:09,270
Super bar : super, és el

33
00:02:09,470 --> 00:02:13,310
receptor. Asi que,
el algoritmo de lookup canvia 

34
00:02:13,510 --> 00:02:15,530
en presencia del receptor super.

35
00:02:16,730 --> 00:02:21,550
Buscaremos el metodo bar a partir
de la super clase

36
00:02:21,750 --> 00:02:23,390
de donse se encuentre la
palabra clave super.

37
00:02:25,350 --> 00:02:29,930
Super se encuentra en el metodo
bar de la clase B, asi que

38
00:02:30,130 --> 00:02:34,080
buscaremos un metodo 
bar a partir de la super

39
00:02:34,280 --> 00:02:35,040
clase de B, és decir A.

40
00:02:36,550 --> 00:02:40,780
Encontramos este metodo y és
este metodo el que sera ejecutado.

41
00:02:41,000 --> 00:02:43,230
Así que foo se envia a self.

42
00:02:43,480 --> 00:02:47,630
Self, és siempre el objeto mismo,
és siempre el receptor, és B new.

43
00:02:48,130 --> 00:02:53,000
Foo és asi enviado al objeto
inicial así pues és este

44
00:02:53,200 --> 00:02:57,210
foo aqui él que sera
ejecutado y devuelve 10.

45
00:02:57,410 --> 00:02:58,250
10 y 10 : 20.

46
00:03:00,380 --> 00:03:04,280
En el caso de C new bar,
tenemos nuestro C new que esta aqui

47
00:03:04,480 --> 00:03:08,950
y que és una instancia de la classe
C y le enviamos el mensaje bar.

48
00:03:09,870 --> 00:03:13,270
Bar se busca en la clase de
C new, és decir C.

49
00:03:14,700 --> 00:03:16,230
No lo encuentra aqui,
lo busca debajo.

50
00:03:17,550 --> 00:03:22,110
Lo encuentra aqui, és pues
esta bar el que se ejecutara.

51
00:03:23,530 --> 00:03:27,680
Este bar és la suma de 2 envios
de mensajes.

52
00:03:28,720 --> 00:03:32,550
Podemos enpezar por el segundo
una vez mas, enviamos

53
00:03:32,750 --> 00:03:34,410
el mensaje foo al objeto self.

54
00:03:34,880 --> 00:03:37,660
Self, és siempre
my C new que se encuentra aqui.

55
00:03:38,130 --> 00:03:39,170
Envio el mensaje foo.

56
00:03:40,170 --> 00:03:41,000
Encuentra este metodo.

57
00:03:41,480 --> 00:03:45,400
Devuelve 50, aqui tengo 50.

58
00:03:46,490 --> 00:03:49,640
Super bar, ahora nos falta la
primera parte

59
00:03:49,840 --> 00:03:51,530
de la suma de super bar.

60
00:03:51,730 --> 00:03:53,720
Envio el mensaje bar a super.

61
00:03:53,920 --> 00:03:56,540
Super, és siempre el receptor
pero el algoritmo de

62
00:03:56,740 --> 00:04:00,690
lookup canvia y buscara bar
a partir de la super clase

63
00:04:00,890 --> 00:04:03,930
del lugar donde se encuentra
la expression que contiene 

64
00:04:04,130 --> 00:04:07,920
super, és decir el metodo bar
de la clase B, és decir

65
00:04:08,130 --> 00:04:11,600
la clase B, así que enpezamos a
buscar ba a partir de

66
00:04:11,800 --> 00:04:12,620
la super clase de B, és decir A.

67
00:04:12,820 --> 00:04:14,700
Bar se encuentra aqui.

68
00:04:14,900 --> 00:04:17,310
És este bar el que se ejecuta.

69
00:04:17,650 --> 00:04:20,880
Self, és siempre C new,
és siempre este,

70
00:04:21,160 --> 00:04:24,040
siempre el receptor y le enviamos
el mensaje foo.


71
00:04:24,700 --> 00:04:29,430
Encontramos el 50.
Aqui tengo 50 : 50 y 50,

72
00:04:30,720 --> 00:04:31,480
100.

73
00:04:31,890 --> 00:04:35,280
En este slide, teneis los detalles
de la ejecución del algoritmo

74
00:04:35,590 --> 00:04:38,570
para poder revisar y volver a
trabajar este ejemplo.

75
00:04:39,710 --> 00:04:44,060
Super esta referenciado siempre
en el receptor, és exactamente

76
00:04:44,460 --> 00:04:47,100
como self o como this en Java.

77
00:04:47,300 --> 00:04:50,100
Y igualmente, super en Java, és
como this en Java, esto 

78
00:04:50,300 --> 00:04:51,250
representa siempre el receptor.

79
00:04:53,220 --> 00:04:56,340
Al contrario cuando un mensaje
se envia a super, el algoritmo

80
00:04:56,540 --> 00:04:59,790
de busqueda canvia y empieza
a buscar un metodo

81
00:05:00,000 --> 00:05:02,920
a partir de la super clase, de 
la clase que contiene el

82
00:05:03,120 --> 00:05:05,230
metodo a ejecutar en el lugar 
donde se encuentra super.


83
00:05:06,100 --> 00:05:11,000
Así self y super tienen una 
diferencia fundamenta: self

84
00:05:11,200 --> 00:05:13,880
és dinamico así que
super és estatico.

85
00:05:14,120 --> 00:05:15,150
Que quiero decir con eso?

86
00:05:17,140 --> 00:05:20,510
Quiero decir que cuando 
foo se envia a self, el

87
00:05:20,710 --> 00:05:23,680
desarrollador no tiene ninguna idea
del metodo foo que se ejecutara.

88
00:05:24,930 --> 00:05:27,950
Puede ser el foo que se 
encuentra en la misma clase,

89
00:05:29,920 --> 00:05:32,860
en una sublaclase existente
o bien en una subclase de una subclase

90
00:05:33,080 --> 00:05:37,750
creada por otro desarrollador
antes de la ejecución del programa.

91
00:05:38,760 --> 00:05:41,880
Así pues cuando el desarrollador
del metodo bar escribe

92
00:05:42,080 --> 00:05:45,140
self foo, no tiene ninguna idea
del metodo foo que se ejecutara.

93
00:05:46,260 --> 00:05:48,660
És especialmente practico,
quiere decir que

94
00:05:48,860 --> 00:05:51,330
los desarrolladores pueden crear
nuevas subclase para canviar

95
00:05:51,530 --> 00:05:54,440
el comportamiento de la clase A.

96
00:05:55,500 --> 00:05:58,200
Super, por contra, és estatico.

97
00:05:58,910 --> 00:06:03,240
Cuando el desarrollador escribe
"Super foo",

98
00:06:04,070 --> 00:06:06,550
Sabe que metodo foo sera ejecutado

99
00:06:07,500 --> 00:06:09,740
cuando se ejecute el programa.

100
00:06:09,940 --> 00:06:14,820
Así que escriviendo esto, sabe
que sera este metodo foo, aqui,

101
00:06:15,020 --> 00:06:16,210
el que se ejecutara.

102
00:06:16,890 --> 00:06:20,110
Siempre, Super es estatico,
cuando se compila sabemos

103
00:06:20,310 --> 00:06:21,330
que metodo se ejecutara.

104
00:06:23,200 --> 00:06:27,000
Desgraciadament, algunos
libros se equivocan en la

105
00:06:27,200 --> 00:06:30,210
definicion de super y dan
definiciones que no tienen este sentido.


106
00:06:31,000 --> 00:06:34,460
Aqui una definicion que encontramos
en un libro y

107
00:06:34,660 --> 00:06:39,400
esta definicion, nos dice que
super busca

108
00:06:40,720 --> 00:06:42,920
el metodo. Así que cuando el 
algoritmo de busqueda vé
l'algorithme de lookup quand il voit

109
00:06:43,120 --> 00:06:46,140
un super buscara el metodo a partir de 
la super clase del receptor.

110
00:06:48,040 --> 00:06:50,080
Asi que la super clase de
la clase del receptor.

111
00:06:50,410 --> 00:06:51,680
De hecho esta definición és falsa.

112
00:06:52,210 --> 00:06:55,580
Si tomoamos el ejemplo siguiente,
si tomamos como 

113
00:06:55,780 --> 00:06:58,570
receptor AC, su clase és C.

114
00:06:59,740 --> 00:07:02,750
La super clase del receptor
és entonces C.

115
00:07:04,060 --> 00:07:08,240
Y aqui, ejecuto esta parte

116
00:07:09,020 --> 00:07:12,120
con la definicion anterior y 

117
00:07:12,320 --> 00:07:16,210
que és falsa, enviariamos el
mensaje foo

118
00:07:16,880 --> 00:07:20,720
a super, y el metodo foo que
se ejecutaria, és el 

119
00:07:20,920 --> 00:07:23,840
metodo foo que se encuentra
en la super clase de la 

120
00:07:24,040 --> 00:07:27,950
la clase del receptor,
és decir este metodo foo aqui


121
00:07:28,150 --> 00:07:30,930
que ejecutaria esto, que
enviaria el mensaje foo a super, que

122
00:07:31,130 --> 00:07:33,400
que ejecutaria esto, y ect..
Así pues vemos aqui que 

123
00:07:33,600 --> 00:07:38,010
entramos en un bucle infinito, esta
claro que la definicion és erronea

124
00:07:38,210 --> 00:07:42,100
porque en la practica no entramos
en un bucle infinito.

125
00:07:42,300 --> 00:07:43,540
Este ejemplo funciona a la perfección.

126
00:07:44,620 --> 00:07:47,430
Así que esta definicion simplemente
és falsa.

127
00:07:47,630 --> 00:07:51,440
Lo que deveis recordar:
Self representa siempre

128
00:07:51,640 --> 00:07:53,710
el receptor igual que Super.

129
00:07:54,100 --> 00:07:58,120
Y igual que this en Java, This 
y Super representan siempre el receptor.

130
00:07:58,940 --> 00:08:01,030
Por contra, super canvia
el algoritmo de busqueda.


131
00:08:01,690 --> 00:08:04,450
El algoritmo de busqueda
buscara el metodo


132
00:08:04,650 --> 00:08:08,100
correspondiente a partir de la
super clase de la clase

133
00:08:08,300 --> 00:08:12,140
que contiene el metodo,
que contiene la palabra clave Super.

134
00:08:12,770 --> 00:08:16,090
Los envios de mensaje a 
Self son dinamicos, y podemos

135
00:08:16,290 --> 00:08:19,150
utilizarlos como desarrolladores
para estender el 

136
00:08:19,350 --> 00:08:21,370
comportamiento de una clase
existente construyendo

137
00:08:21,570 --> 00:08:23,300
una subclas que redefine 
un metodo.
